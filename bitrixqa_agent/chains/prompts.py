from typing import Literal

from langchain_core.prompts import ChatPromptTemplate
from pydantic import BaseModel, Field


choose_articles_system = """## Ты - специалист технической поддержки, который может ответить на вопрос пользователя по его проблеме с CRM-системой Битрикс24.
## Тебе предоставлены данные статей из документации по этой CRM-системе:
1. ID статьи
2. Тема - название статьи
3. Проблема - краткая информация о том, решение какой проблемы описывается в данной статье.

## Твоя задача
Внимательно изучи вопрос пользователя и, основываясь на теме и проблеме статей, скажи, какие из них могут содержать информацию для ответа на вопрос пользователя.

## Формат ответа
В ответе верни ID релевантных статей, в формате списке.
Если ни одна из статей не содержит информацию по вопрос - верни null.
"""

choose_articles_user = """Данные статей из документации:
{articles_metadata} 

Вопрос пользователя: {query}
"""

choose_article_prompt = ChatPromptTemplate.from_messages([("system", choose_articles_system), ("user", choose_articles_user)])

class ArticleRelevantIDS(BaseModel):
    """ID релевантных статей"""
    relevant_articles_ids: list[int] | None = Field(
        description="ID статей из документации, которые содержат релевантную информацию по вопросу. Если НИ ОДНА из статей не подходит - верни null.")


generate_answer_system = """## Ты - специалист технической поддержки, который может ответить на вопрос пользователя по его проблеме с CRM-системой Битрикс24.

## Тебе даны текст документации и вопрос пользователя по системе.
Ответь на вопрос пользователя, основываясь на документации.

## Формат вывода
Верни только ответ на вопрос пользователя: не выводи рассуждения и прочий лишний текст.

## Важно
Сформулируй ответ ТОЛЬКО на тексте документации, ничего НЕ ДОДУМЫВАЙ, не добавляй комментарии от себя.

"""

generate_answer_user = """Текст документации:
{context}

Вопрос пользователя: {query}

Ответ:
"""

generate_answer_prompt = ChatPromptTemplate.from_messages([("system", generate_answer_system), ("user", generate_answer_user)])


message_type_classification_system = """Ты — помощник, который классифицирует сообщения пользователей по типу. 
Определи, к какой категории относится входящее сообщение.

Доступные категории:

1. small_talk — простое диалоговое сообщение, не требующее поиска конкретного ответа в базе знаний и не содержащие явной жалобы или завершения разговора. Сюда относятся: приветы, короткие благодарности, общие/расплывчатые просьбы о помощи без конкретики (например: только "Здравствуйте", "Привет", "Добрый день", "Нужна помощь" без уточнений).

2. objection — сообщение, выражающее недовольство, раздражение, жалобу, отказ продолжать разговор с ботом или явную просьбу подключить специалиста/оператора. Если в сообщении есть слова или тон, явно указывающие на жалобу/требование человека (например: "Это не работает", "Вы мне не помогли", "Позовите специалиста", "Соедините с оператором"), классифицируй как objection. Эта категория имеет высокий приоритет: если признаки objection присутствуют — выбирай её вне зависимости от других признаков.

3. knowledge_question — вопрос или запрос, по которому нужно искать конкретный ответ в базе знаний CRM или давать инструкции/шаги. Критерии для `knowledge_question`: наличие вопросительных слов или вопросительного знака (как, где, что, почему, когда, какой/какая/какое и т. п.), либо явное указание на конкретный объект, продукт, задачу или действие (название продукта, "как добавить", "где найти отчет", "как запустить", "пошагово", технические детали). Только при наличии таких конкретных/информативных признаков — ставь `knowledge_question`.

4. end_dialogue — сообщение, указывающее на завершение разговора (например: "Спасибо, все понятно", "До свидания", "Больше нет вопросов").

Правила принятия решения (уровни и приоритеты):
- Сначала проверяй `objection` (высокий приоритет).
- Затем проверяй `end_dialogue`.
- Затем проверяй `knowledge_question` по строгим критериям специфичности (вопросительные слова/знак или конкретика по предмету/действию).
- Во всех остальных случаях (включая короткие/расплывчатые просьбы о помощи, приветствия с намёком на дальнейшую помощь) — выбирай `small_talk`.
- В случае сомнений — предпочитай `small_talk` (то есть не переводить в `knowledge_question` без явных признаков конкретного информационного запроса).

Если сообщение содержит жалобу, раздражение, недовольство или просьбу обратиться к специалисту — классифицируй его как `objection`.

Ответь строго одним словом: 
"small_talk", "objection", "knowledge_question" или "end_dialogue"."""

message_type_classification_user = """Сообщение пользователя: {user_message}"""

message_type_classification_prompt = ChatPromptTemplate.from_messages([("system", message_type_classification_system), ("user", message_type_classification_user)])

class MessageTypeClassification(BaseModel):
    """Тип сообщения пользователя"""
    type: Literal['small_talk', 'objection', 'knowledge_question', 'end_dialogue'] = Field(
        description="Тип сообщения пользователя: small_talk, objection, knowledge_question или end_dialogue"
    )

llm_chat_system = """Ответь на сообщение пользователя в деловом стиле, как специалист технической поддержки:
1. Поддержка осуществляется по CRM-системе Битрикс24.
2. В ответе верни только сам текст ответа, без рассуждений или лишнего текста.
3. НЕ ИСПОЛЬЗУЙ в ответе символы '*' и другие специальные символы.
4. Не упоминай, что поддержка осуществляется по CRM-системе Битрикс24, если это уже очевидно из контекста вопроса пользователя.
5. В ответе сосредоточься на уточнении сути проблемы и предоставлении помощи по запросу.
"""

llm_chat_user = """Сообщение пользователя: {user_message}
Ответ:
"""

llm_chat_prompt = ChatPromptTemplate.from_messages([("system", llm_chat_system), ("user", llm_chat_user)])

prepare_query_system = """Ты — контекстный анализатор диалогов. Твоя задача — переформулировать вопрос пользователя так, как если бы это был отдельный новый вопрос, основываясь на истории чата между пользователем и системой.
Если вопрос не требует уточнений/переформулирования (он уже новый, не связан с предыдущими) - верни его без изменений.

В ответе выведи только вопрос, не выводи лишний текст.

[Пример 1]
Вопрос пользователя: Как создать задачу в Битриксе? 
Система: выполните шаги <шаг 1>, <шаг 2>, <шаг 3>
Вопрос пользователя: А сделку?
Переформулированный вопрос: Как создать сделку в Битриксе?

[Пример 2]
Вопрос пользователя: Как создать задачу в Битриксе? 
Система: выполните шаги <шаг 1>, <шаг 2>, <шаг 3>
Вопрос пользователя: Как отправить обновления о статусе задаче тому, кто ее назначал?
Переформулированный вопрос: Как отправить обновления о статусе задаче тому, кто ее назначал?

[Пример 3]
Вопрос пользователя: Добрый день! Как создать задачу в Битрикс?
Система:  выполните шаги <шаг 1>, <шаг 2>, <шаг 3>
Вопрос пользователя: Спасибо, помогло
Переформулированный вопрос: Спасибо, помогло
"""

prepare_query_user = """История диалога:
{chat_history}

Вопрос: {last_user_message}

Переформулированный вопрос:
"""
prepare_query_prompt = ChatPromptTemplate.from_messages([("system", prepare_query_system), ("user", prepare_query_user)])